#' Plot Method for pinp_fit Objects
#'
#' Provides a visualization of the prediction intervals generated by a `pinp_fit` object.
#' It plots the training data, the predicted intervals as a ribbon, and optionally
#' highlights the points where a fallback prediction was used.
#'
#' @param x A fitted object of class `pinp_fit`.
#' @param n_grid An integer specifying the number of points to use for the prediction grid.
#' @param show_fallback A logical value indicating whether to highlight fallback points.
#' @param ... Additional arguments passed to `predict_intervals`, such as `alpha`.
#'
#' @return A `ggplot` object, which is also printed to the console.
#'
#' @method plot pinp_fit
#' @export
#' @importFrom ggplot2 ggplot aes aes_string geom_point geom_ribbon labs theme_minimal
plot.pinp_fit <- function(x, n_grid = 100, show_fallback = TRUE, ...) {
  # 1. Extract training data
  train_X <- x$model_internal$X_train
  train_y <- x$model_internal$y_train

  if (ncol(train_X) > 1) {
    stop("Plotting for multi-dimensional X is not yet implemented.", call. = FALSE)
  }
  
  col_name_x <- colnames(train_X)[1]
  data_train <- data.frame(X1 = train_X[[col_name_x]], y = train_y)
  colnames(data_train)[1] <- col_name_x

  # 2. Create base ggplot layer with training points
  g <- ggplot(data_train, aes_string(x = col_name_x, y = "y")) + 
    geom_point(alpha = 0.3)

  # 3. Create a prediction grid
  x_range <- range(data_train[[col_name_x]])
  X_new_grid <- seq(x_range[1], x_range[2], length.out = n_grid)
  X_new_df <- data.frame(X1 = X_new_grid)
  colnames(X_new_df)[1] <- col_name_x

  # 4. Call predict_intervals to get the intervals
  pi <- predict_intervals(x, X_new_df, ...) # Changed to pass ... directly
  
  plot_data <- cbind(X_new_df, pi)

  # 5. Add the geom_ribbon layer for the prediction intervals
  g <- g + geom_ribbon(data = plot_data, 
                       aes_string(x = col_name_x, ymin = "lower", ymax = "upper"), 
                       inherit.aes = FALSE, 
                       fill = "lightblue", 
                       alpha = 0.5)

  # 6. Check if fallback points should be highlighted
  if (show_fallback && "warning" %in% colnames(pi)) {
    fallback_points <- plot_data[!is.na(pi$warning), ]
    if (nrow(fallback_points) > 0) {
      # Add points to highlight where the fallback was triggered
      g <- g + geom_point(data = fallback_points, 
                          aes_string(x = col_name_x, y = "lower"), 
                          inherit.aes = FALSE, 
                          color = "red", 
                          shape = 4, 
                          size = 2)
      g <- g + geom_point(data = fallback_points, 
                          aes_string(x = col_name_x, y = "upper"), 
                          inherit.aes = FALSE, 
                          color = "red", 
                          shape = 4, 
                          size = 2)
    }
  }
  
  # Add labels and theme
  g <- g + labs(title = paste("Prediction Intervals (Method:", x$method, ")"),
                x = col_name_x,
                y = "Y") +
           theme_minimal()

  # 7. Print the ggplot object
  print(g)
  
  # Return invisibly
  invisible(g)
}

# Helper for default alpha if not provided in ...
`%||%` <- function(a, b) {
  if (!is.null(a)) a else b
}

#' Compare Prediction Intervals of Two Models
#'
#' Plots the prediction intervals from two different `pinp_fit` models on the
#' same data for visual comparison.
#'
#' @param model1 The first fitted object of class `pinp_fit`.
#' @param model2 The second fitted object of class `pinp_fit`.
#' @param data The training data frame used for plotting the points. The formula
#'   from `model1` will be used to extract the correct columns.
#' @param n_grid An integer specifying the number of points for the prediction grid.
#' @param ... Additional arguments passed to both `predict_intervals` calls.
#' @param model1_name A character string for the name of the first model in the plot title.
#' @param model2_name A character string for the name of the second model in the plot title.
#'
#' @return A `ggplot` object, which is also printed to the console.
#'
#' @export
#' @importFrom ggplot2 ggplot aes_string geom_point geom_ribbon ggtitle labs theme_minimal
plot_compare <- function(model1, model2, data, n_grid = 100, ..., model1_name = "Model 1 (blue)", model2_name = "Model 2 (red)") {
  # a. Extract training data 'X' and 'y' from the 'data' argument
  if (ncol(model1$model_internal$X_train) > 1) {
    stop("Plotting for multi-dimensional X is not yet implemented.", call. = FALSE)
  }
  
  formula <- model1$formula
  mf <- model.frame(formula, data)
  y <- model.response(mf)
  
  predictor_name <- all.vars(formula)[-1]
  if (length(predictor_name) > 1) {
      stop("Plotting for multi-dimensional X is not yet implemented.", call. = FALSE)
  }
  X <- mf[[predictor_name]]
  
  plot_data_train <- data.frame(x = X, y = y)
  colnames(plot_data_train) <- c(predictor_name, "y")

  # b. Create a prediction grid 'X_new_df'
  x_range <- range(X)
  X_new_grid <- seq(x_range[1], x_range[2], length.out = n_grid)
  X_new_df <- data.frame(x = X_new_grid)
  colnames(X_new_df) <- predictor_name

  # c. Call predict_intervals for model1
  pi1 <- predict_intervals(model1, X_new_df, ...)
  plot_data1 <- cbind(X_new_df, pi1)

  # d. Call predict_intervals for model2
  pi2 <- predict_intervals(model2, X_new_df, ...)
  plot_data2 <- cbind(X_new_df, pi2)

  # e-f. Create ggplot object and add points
  g <- ggplot(plot_data_train, aes_string(x = predictor_name, y = "y")) +
    geom_point(color = "grey40", alpha = 0.5) +
    # g. Add 'geom_ribbon' for Model 1
    geom_ribbon(data = plot_data1, aes_string(x = predictor_name, ymin = "lower", ymax = "upper"), 
                inherit.aes = FALSE, fill = "blue", alpha = 0.4) +
    # h. Add 'geom_ribbon' for Model 2
    geom_ribbon(data = plot_data2, aes_string(x = predictor_name, ymin = "lower", ymax = "upper"), 
                inherit.aes = FALSE, fill = "red", alpha = 0.4) +
    # i. Set a 'ggtitle'
    ggtitle(paste(model1_name, "vs", model2_name)) +
    labs(x = predictor_name, y = "Y") +
    theme_minimal()
    
  # j. Print the final plot 'g'
  print(g)
  invisible(g)
}
